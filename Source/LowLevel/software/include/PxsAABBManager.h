/*
 * Copyright (c) 2008-2015, NVIDIA CORPORATION.  All rights reserved.
 *
 * NVIDIA CORPORATION and its licensors retain all intellectual property
 * and proprietary rights in and to this software, related documentation
 * and any modifications thereto.  Any use, reproduction, disclosure or
 * distribution of this software and related documentation without an express
 * license agreement from NVIDIA CORPORATION is strictly prohibited.
 */
// Copyright (c) 2004-2008 AGEIA Technologies, Inc. All rights reserved.
// Copyright (c) 2001-2004 NovodeX AG. All rights reserved.  


#ifndef PXS_AABB_MANAGER_H
#define PXS_AABB_MANAGER_H

#include "PxsBroadPhaseCommon.h"
#include "PxsAABBManagerAux.h"
#include "PxsAABBManagerTasks.h"
#include "PxsAABBManagerId.h"

#ifndef __SPU__
#include "PxTask.h"
#endif

namespace physx
{
namespace Cm
{	
	class RenderOutput;
	class EventProfiler;
}

class PxBaseTask;
class PxLightCpuTask;

class BPTasks;
class PxvBroadPhase;
class PxsRigidBody;
class PxsContext;

class PxsAABBManager : public Ps::UserAllocated
{
	PX_NOCOPY(PxsAABBManager)

	public:

		friend class SingleAABBUpdateTask;
		friend class SingleAABBTask;
#ifdef PX_PS3
		friend class SingleAABBTaskSPU;
#endif

		friend class ActorAABBUpdateTask;
		friend class ActorAABBTask;

		friend class AggregateAABBUpdateTask;
		friend class AggregateAABBTask;

		friend class BPWorkTask;
		friend class ProcessBPResultsTask;

		friend class AggregateOverlapTask;
		friend class AggregateOverlapWorkTask;

		friend class FinishTask;

		PxsAABBManager(Cm::EventProfiler& eventProfiler, PxcScratchAllocator& scratchAllocator);
		~PxsAABBManager();

		//init/destroy/etc
		void init(PxvBroadPhase* bp);
		void preAllocate(const PxU32 nbStaticShapes, const PxU32 nbDynamicShapes, const PxU32 numAggregates);
		void destroyV();

		void visualize(Cm::RenderOutput& out);

		//create/delete aggregate
		PxU32 createAggregate(void* userData, const bool selfCollisions);
		void deleteAggregate(const PxU32 aggregateId);

		//create/init/release volume
		//aggregateId stored in actorCore - PX_INVALID_BP_HANDLE for non-aggregate volume, value generated by createAggregate. 
		//actorHandle stored in PxcRigidBody - PX_INVALID_BP_HANDLE for first shape of an aggregate or non-aggregate rigid body.  
		//NOTE: createVolume returns a unique shape handle in the returned AABBMgrId
		//NOTE: If actorHandle has value PX_INVALID_BP_HANDLE this indicates the volume being created is the first to be added to the corresponding actor.
		//A unique actor handle is created and stored in AABBMgrId so that subsequent shapes added to the same actor can pass the created actor handle to createVolume.
		//NOTE: If actorHandle is not equal to PX_INVALID_BP_HANDLE this indicates a shape is being added to an actor that already has shapes.  The returned AABBMgrId
		//will contain the unique shape handle for the created volume and the actor handle passed to createVolume.
		AABBMgrId createVolume(const PxU32 aggregateId, const PxcBpHandle actorHandle, const PxU32 group, void* userdata, const PxBounds3& bounds);
		void setDynamicAABBData(const PxcBpHandle shapeHandle, const PxcAABBDataDynamic& aabbData);
		void setStaticAABBData(const PxcBpHandle shapeHandle, const PxcAABBDataStatic& aabbData);

		//return true if released last shape
		bool releaseVolume(const PxcBpHandle shapeHandle);
		void setVolumeBounds(const PxcBpHandle shapeHandle, const PxBounds3& bounds);

		//An actor is dirty if it has a deleted/added shape or a shape with a modified local pose or a shape with modified geometry.
		void setActorDirty(const PxcBpHandle actorHandle);

		//query volume
		PxBounds3 getBPBounds(const PxcBpHandle shapeHandle) const;

		//Update aabbs and sap.
		void updateAABBsAndBP(
			const PxU32 numCpuTasks, const PxU32 numSpusAABB, const PxU32 numSpusBP, PxBaseTask* continuation,
			PxU32* PX_RESTRICT changedShapeWords, const PxU32 changedShapeWordCount, 						
			const bool secondBroadPhase, PxI32* numFastMovingShapes);

		//Query the results of the broadphase update reported back to the high-level for filtering.
		PX_FORCE_INLINE	PxU32						getCreatedOverlapsCount()	const	{ return mCreatedPairsSize;		}
		PX_FORCE_INLINE	const PxvBroadPhaseOverlap* getCreatedOverlaps()		const	{ return mCreatedPairs;			}
						void						freeCreatedOverlaps();

		PX_FORCE_INLINE	PxU32						getDestroyedOverlapsCount()	const	{ return mDeletedPairsSize;		}
		PX_FORCE_INLINE	const PxvBroadPhaseOverlap*	getDestroyedOverlaps()		const	{ return mDeletedPairs;			}
						void						freeDestroyedOverlaps();

		PX_FORCE_INLINE	PxvBroadPhase*				getBroadPhase()				const	{ return mBP;					}
		PX_FORCE_INLINE	Ps::Array<void*>&			getOutOfBoundsObjects()				{ return mOutOfBoundsObjects;	}
		PX_FORCE_INLINE	Ps::Array<void*>&			getOutOfBoundsAggregates()			{ return mOutOfBoundsAggregates;}

		// shift origin of AABBs
		void shiftOrigin(const PxVec3& shift);

	private:

		////////////////////////////////////////////////////
		//Overlap bp results (single - aggregate, aggregate - aggregate) and self-collision
		////////////////////////////////////////////////////

		//Add/remove overlap pair to lists of shape pairs with overlapping aabbs.
		static void addCreatedPair(PxcScratchAllocator* scratchAllocator, void* userdata0, void* userdata1, PxvBroadPhaseOverlap*& createdOverlaps, PxU32& createdOverlapsSize, PxU32& createdOverlapsCapacity);
		static void addDeletedPair(PxcScratchAllocator* scratchAllocator, void* userdata0, void* userdata1, PxvBroadPhaseOverlap*& deletedOverlaps, PxU32& deletedOverlapsSize, PxU32& deletedOverlapsCapacity);

		//Add/remove bp overlap pairs involving aggregates.
		AggregatePair& addAggregatePair(const PxcBpHandle bpElemId0, const PxcBpHandle bpElemId1);
		bool removeAggregatePair(const PxcBpHandle bpElemId0, const PxcBpHandle bpElemId1);
		void removeAggregateAggregatePair(Aggregate* PX_RESTRICT c0, Aggregate* PX_RESTRICT c1, Cm::BitMap* PX_RESTRICT aggregateCollBitmap);
		void removeAggregateSinglePair(const PxcBpHandle s0, Aggregate* PX_RESTRICT c1, Cm::BitMap* PX_RESTRICT aggregateCollBitmap);

		//Self-, aggregate-aggregate and aggregate-single overlaps.
		void sortAggregates(PxcBpHandle* allRankIds, const PxU32 allRankIdsCapacity, PxcBpHandle* allElemIds, const PxU32 allElemIdsCapacity, AggregateSortedData* aggregateSortedData);
		void selfCollideAggregates
			(const PxU32 startId, const PxU32 nbWorkItems, const AggregateSortedData* aggregateSortedDatas,
			PxvBroadPhaseOverlap*& createdPairs, PxU32& createdPairsSize, PxU32& createdPairsCapacity,
			PxvBroadPhaseOverlap*& deletedPairs, PxU32& deletedPairsSize, PxU32& deletedPairsCapacity);
		void selfCollideAggregate
			(const AggregateSortedData& aggregateSortedData, const Aggregate& aggregate, SelfCollideBitmap* selfCollideBitmap,
			PxvBroadPhaseOverlap*& createdPairs, PxU32& createdPairsSize, PxU32& createdPairsCapacity,
			PxvBroadPhaseOverlap*& deletedPairs, PxU32& deletedPairsSize, PxU32& deletedPairsCapacity);
		void initialiseAggregateAggregateBitmaps();
		void processAggregatePairs
			(const PxU32 startId, const PxU32 nbWorkItems, const AggregateSortedData* aggregateSortedDatas,
			PxvBroadPhaseOverlap*& createdPairs, PxU32& createdPairsSize, PxU32& createdPairsCapacity,
			PxvBroadPhaseOverlap*& deletedPairs, PxU32& deletedPairsSize, PxU32& deletedPairsCapacity);
		void processAggregateAggregate
			(const AggregateSortedData& aggregateSortedData0, const Aggregate& aggregate0, const AggregateSortedData& aggregateSortedData1, const Aggregate& aggregate1, 
			Cm::BitMap* overlapBitmap, 
			PxvBroadPhaseOverlap*&createdPairs, PxU32& createdPairsSize, PxU32& createdPairsCapacity, 
			PxvBroadPhaseOverlap*& deletedPairs, PxU32& deletedPairsSize, PxU32& deletedPairsCapacity);
		void processAggregateSingle
			(const AggregateSortedData& aggregateSortedData, const Aggregate& aggregate, const PxU32 singleId, 
			Cm::BitMap* overlapBitmap, 
			PxvBroadPhaseOverlap*&createdPairs, PxU32& createdPairsSize, PxU32& createdPairsCapacity, 
			PxvBroadPhaseOverlap*& deletedPairs, PxU32& deletedPairsSize, PxU32& deletedPairsCapacity);


		///////////////////////////////////////////////////////////
		//Called form createVolume.
		///////////////////////////////////////////////////////////

		PxcBpHandle createBPElem();
		PxcBpHandle createAggregateElem();
		void promoteBitmaps(Aggregate* aggregate);
		Cm::BitMap*	promoteBitmap(Cm::BitMap* bitmap, PxU32 nbX, PxU32 nbY, PxU32 newXIndex, PxU32 newYIndex) const;

		///////////////////////////////////////////////////
		//Called from releaseVolume
		///////////////////////////////////////////////////

		void purgeAggregatePairs(const PxcBpHandle bpElemId);

		///////////////////////////////////////////////////
		//Called from setVolumeBounds  and shiftOrigin
		///////////////////////////////////////////////////

		void setBPElemVolumeBounds(const PxcBpHandle singleId, const IntegerAABB& bounds);
		void setAggregateElemVolumeBounds(const PxcBpHandle elemId, const IntegerAABB& bounds);

		///////////////////////////////////////////////////
		//Called during the update process
		///////////////////////////////////////////////////

		//Compute the lists of bp and aggregate elems that need to be updated.
		//Called from updateAABBsAndBP
		void computeAABBUpdateLists(PxU32* PX_RESTRICT changedActorWords, const PxU32 changedActorWordCount, const PxsComputeAABBParams& params); 						

		//Remove actors in aggregates that have zero shapes.
		//The actor is removed from the actor list for each aggregate, thereby removing the need to check for holes in the list.  
		//The corresponding entries in AggregateActorManager can be reused because it is no longer referenced.
		//Called from updateAABBsAndBP
		void removeEmptyActorsFromAggregates();

		//Pass the updated bounds data to the bp.
		//Called from BPWorkTask.
		void prepareBP();

		//After the sap we need to consider single-aggregate and aggregate-aggregate overlaps reported by the sap.
		//Called from ProcessBPResultsTask.
		void processBPResults(const PxsComputeAABBParams& params);

		//Update record of all aggregates that have a broadphase overlap.
		void updateAggregateBPOverlapRecords();

		///////////////////////////////////////////////////////////

		PxcScratchAllocator& mScratchAllocator;
		Cm::EventProfiler& mEventProfiler;

		////////////////////////////////////////////////////

		//AABBs that have bp entries.  A bp entry is a bounds computed from either 
		//1. the bounds of a single shape 
		//2. the aggregated bounds of an aggregate containing potentially multiple actors and shapes.
		//Single bounds have an index to an entry in SingleManager (this stores the head of the list of all actor shapes). 
		//Aggregate bounds have an index to an entry in AggregateManager (this stores the head of the list of all aggregate shapes and actors).
		BPElems						mBPElems;

		//bp element lists that have been updated/created/removed.
		ChangeList  mBPUpdatedElems;
		ChangeList  mBPCreatedElems;
		ChangeList  mBPRemovedElems;

		////////////////////////////////////////////////////

		//Each shape not in an aggregate belongs to a single actor that has a list of shapes and a bp entry per shape.
		//SingleManager allows each shape to point to an actor that in turn points to a list of all shapes and bp entries of the actor.
		//The list of shapes and their bp entries are stored in BPElems
		//The head of the list is stored in SingleManager
		SingleManager				mSingleManager;

		////////////////////////////////////////////////////

		//An aggregate has a list of all shapes in the aggregate and a list of all actors in the aggregate.	
		//The list of shapes and their bounds are stored in AggregateElems
		//The list of actors is stored in AggregateActorManager
		//The heads of the lists of shapes and actors is stored in AggregateManager
		//Each shape in AggregateElems has an index to the corresponding actor in AggregateActorManager
		//Each actor in AggregateActorManager has an index to an aggregate in AggregateManager
		//The index of the bp entry of an aggregate is stored in AggregateManager and the bounds is stored in mBPElems.
		AggregateManager			mAggregateManager;
		AggregateActorManager		mAggregateActorManager;
		AggregateElems				mAggregateElems;

		//A record of all aggregates that require an update of the aggregate bounds.
		//An aggregate needs its aggregate bounds updated if any actor has moved 
		//or if any shape of any actor in the aggregate has been added/removed, had its local pose modified
		//or had its shape modified.
		ChangeList 	mAggregatesUpdated;

		//Optimisation structures for aggregate-aggregate, aggregate-single overlaps and for aggregate self-collision 
		PxU32						mBitmasks[32];

		////////////////////////////////////////////////////

		//Shapes in singles that need their bounds updated.
		//Need to store this on the heap rather than temporarily on the stack because we need to perform a dma to spu.
		InlineBuffer<PxcBpHandle, MAX_NUM_BP_SPU_SAP_AABB>	mBPUpdatedElemIds;
		PxU32						mBPUpdatedElemIdsSize;

		//Shapes in aggregates that need their bounds updated.
		//Need to store this on the heap rather than temporarily on the stack because we need to perform a dma to spu.
		InlineBuffer<PxcBpHandle, MAX_NUM_BP_SPU_SAP_AABB>	mAggregateUpdatedElemIds;
		PxU32						mAggregateUpdatedElemIdsSize;

#ifdef PX_PS3
		//Work to do on each spu when updating single bounds.
		//Each spu updates all bounds requiring an update in blocks of 32 starting from the start of the bounds array.
		InlineBuffer<PxcBpHandle, MAX_NUM_BP_SPU_SAP_AABB>>5>	mBPUpdatedElemWordStarts;				
		InlineBuffer<PxcBpHandle, MAX_NUM_BP_SPU_SAP_AABB>>5>	mBPUpdatedElemWordEnds;				
		PxU32						mBPUpdatedElemWordCount;

		//Work to do on each spu when updating aggregate shape bounds.
		//Each spu updates all bounds requiring an update in blocks of 32 starting from the start of the bounds array.
		InlineBuffer<PxcBpHandle, MAX_NUM_BP_SPU_SAP_AABB>>5>	mAggregateUpdatedElemWordStarts;				
		InlineBuffer<PxcBpHandle, MAX_NUM_BP_SPU_SAP_AABB>>5>	mAggregateUpdatedElemWordEnds;				
		PxU32						mAggregateUpdatedElemWordCount;
#endif

		//////////////////////////////////////////////////////

		//Any valid shape id for each actor in an aggregate.  
		//With a valid shape id, the PxcRigidBody and PxsRigidCore can be retrieved for each actor.
		//This allows the actor's world space bounds to be computed from the cached local space bounds.
		InlineBuffer<PxcBpHandle, 1024> mAggregateActorShapeIds;

		//An array of aggregates with a dirty actor.
		InlineBuffer<PxcBpHandle, 1024> mDirtyActorAggregates;
		PxU32 mNumDirtyActorAggregates;

		//////////////////////////////////////////////////////

		//Indices of aggregates that need sorted because they are involved in 
		//self-, aggregate-single or aggregate-aggregate overlaps.
		InlineBuffer<PxcBpHandle, 1024> mAggregatesToSort;
		PxU32 mNumAggregatesToSort;

		//Indices of aggregate overlap pairs (aggregate-single or aggregate-aggregate
		//that need overlapped because at least one of the pair has been updated).
		InlineBuffer<PxcBpHandle, 1024> mAggregatePairsToOverlap;
		PxU32 mNumAggregatePairsToOverlap;

		////////////////////////////////////////////////////

		// Broadphase
		PxvBroadPhase*			mBP;

		// Broadphase results.
		PxvBroadPhaseOverlap*	mCreatedPairs;
		PxU32					mCreatedPairsSize;
		PxU32					mCreatedPairsCapacity;
		PxvBroadPhaseOverlap*	mDeletedPairs;
		PxU32					mDeletedPairsSize;
		PxU32					mDeletedPairsCapacity;
		AggregatePair*			mAggregatePairs;
		PxU32					mAggregatePairsSize;
		PxU32					mAggregatePairsCapacity;

		///////////////////////////////////////////////////////////

		//Tasks that perform the aabb updates and broadphase
#ifndef __SPU__
		SingleAABBTask			mSingleShapeAABBTask;
		ActorAABBTask			mActorAABBTask;
		AggregateAABBTask		mAggregateAABBTask;
		BPWorkTask				mBPWorkTask;
		ProcessBPResultsTask	mProcessBPResultsTask;
		SingleAABBTask			mAggregateShapeAABBTask;
		AggregateOverlapTask	mAggregateOverlapTask;
		FinishTask				mFinishTask;
#endif


		///////////////////////////////////////////////////////////
		//Objects that are not in a defined region in the case that
		//mbp is the chosen broadphase method.

		Ps::Array<void*>		mOutOfBoundsObjects;
		Ps::Array<void*>		mOutOfBoundsAggregates;
};

} //namespace physx

#endif //PXS_AABB_MANAGER_H
